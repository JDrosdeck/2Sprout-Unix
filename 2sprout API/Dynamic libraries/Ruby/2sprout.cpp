/*THIS IS AN UNPUBLISHED WORK CONTAINING 2SPROUT INC CONFIDENTIAL AND PROPRIETARY INFORMATION. DISCLOSURE, USE, OR REPRODUCTION WITHOUT AUTHORIZATION OF 2SPROUT INC IS STRICTLY PROHIBITED.*/#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <errno.h>#include <string.h>#include <iostream>#include <ctype.h>#include <sys/stat.h>#include <fcntl.h>#include <fstream>#include <sys/types.h>#include <unistd.h>#include <queue>#define sproutPipe "/tmp/2sprout"#define feedPipe "/tmp/feedPipe"#define maxPipe		255#define maxFeedPipe		1000using namespace std;queue<string> feedData;int startFeed(int portNumber){	int fd,n;	char buffer[50];	n = sprintf(buffer, "startFeed %i", portNumber);	fd = open(sproutPipe, O_WRONLY);	write(fd, buffer, strlen(buffer));	return 1;}int stopFeed(int portNumber){	int fd,n;	char buffer[50];	n = sprintf(buffer, "stopFeed %i", portNumber);	fd = open(sproutPipe, O_WRONLY);	write(fd, buffer, strlen(buffer));	return 1;}int getFeed(){	int fd,n;	char buffer[50];	n = sprintf(buffer, "getFeed");	fd = open(sproutPipe, O_WRONLY);	write(fd, buffer, strlen(buffer));		printf("getFeed api call complete");		int fd1, numread;	char bufpipe[maxFeedPipe];		printf("Waiting for data on pipe\n");	while(1)	{		fd1 = open(feedPipe, O_RDONLY);		numread = read(fd1,bufpipe, maxFeedPipe);		printf("Recieved %s from Feed Pipe\n", bufpipe);		feedData.push(bufpipe);		memset(bufpipe,'\0',maxFeedPipe +1);	}	return 1;}char* getNextItem(){	while(1)	{		if(usleep(100000) == -1)		{			printf("Sleeping Error");		}				if(!feedData.empty())		{			string g = feedData.front();			feedData.pop();			return (char *)g.c_str();		}	}	}/*when a developer is using the api they must program using at least two threads, one which calls getFeed()Which will constantly read from the pipe to gather new data, and another which calls getNextItem() whichreturns the next value in the queue.*/