/*THIS IS AN UNPUBLISHED WORK CONTAINING 2SPROUT INC CONFIDENTIAL AND PROPRIETARY INFORMATION. DISCLOSURE, USE, OR REPRODUCTION WITHOUT AUTHORIZATION OF 2SPROUT INC IS STRICTLY PROHIBITED.*/#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <errno.h>#include <string.h>#include <iostream>#include <ctype.h>#include <sys/stat.h>#include <fcntl.h>#include <fstream>#include <sys/types.h>#include <unistd.h>#include <cstdlib>#include <sys/socket.h>#include <sys/un.h>#include <errno.h>#include <string.h>#include <sys/select.h>#include <sys/time.h>#include <sys/wait.h>#include <sys/types.h>#include <sys/ipc.h>#include <sys/msg.h>#include <stdio.h>#include <cstdlib>#define sproutPipe "/tmp/2sprout"#define feedPipe "/tmp/2sproutAPI"using namespace std;#define MSGSZ     50000typedef struct msgbuf {    long    mtype;    char    mtext[MSGSZ];} message_buf;message_buf  rbuf;ssize_t r_read(int fd, char *buf, size_t size) {   ssize_t retval;   while (retval = read(fd, buf, size), retval == -1 && errno == EINTR) ;   return retval;}ssize_t r_write(int fd, char *buf, size_t size) {   char *bufp;   size_t bytestowrite;   ssize_t byteswritten;   size_t totalbytes;   for (bufp = buf, bytestowrite = size, totalbytes = 0;        bytestowrite > 0;        bufp += byteswritten, bytestowrite -= byteswritten) {      byteswritten = write(fd, bufp, bytestowrite);      if ((byteswritten) == -1 && (errno != EINTR))         return -1;      if (byteswritten == -1)         byteswritten = 0;      totalbytes += byteswritten;   }   return totalbytes;}int startFeed(){	int fd,n;	string startFeed = "startFeed";		int sizeOfString = strlen(startFeed.c_str());	char sizeofStringBuffer[10];		sprintf(sizeofStringBuffer, "%i", sizeOfString);	string actualString = sizeofStringBuffer;	int tempSize = strlen(sizeofStringBuffer);		int remainder = 4 - tempSize;	int x;	for(x =0; x < remainder; x++)	{		actualString = actualString + "^";	}		actualString = actualString + startFeed;	fd = open(sproutPipe, O_WRONLY);	write(fd, actualString.c_str(), strlen(actualString.c_str()));	close(fd);	return 1;}/*2Sprout API stopFeed()This function will tell the Client to stop recieving packetsThe client will then tell the server to end broadcasting to this client.*/int stopFeed(){	int fd,n;	string stopFeed = "stopFeed";	int sizeOfString = strlen(stopFeed.c_str());	char sizeofStringBuffer[10];	sprintf(sizeofStringBuffer, "%i", sizeOfString);	string actualString = sizeofStringBuffer;	int tempSize = strlen(sizeofStringBuffer);		int remainder = 4 - tempSize;	int x;	for(x =0; x < remainder; x++)	{		actualString = actualString + "^";	}	actualString = actualString + stopFeed;	fd = open(sproutPipe, O_WRONLY);	write(fd, actualString.c_str(), strlen(actualString.c_str()));	close(fd);	return 1;}/*2Sprout API getFeed()This function tells the Client that we are ready to start recieving data from the Client*/int getFeed(){	/*	int fd,n;	string getFeed = "getFeed";	int sizeOfString = strlen(getFeed.c_str());	char sizeofStringBuffer[10];	sprintf(sizeofStringBuffer, "%i", sizeOfString);	string actualString = sizeofStringBuffer;	int tempSize = strlen(sizeofStringBuffer);		int remainder = 4 - tempSize;	int x;	for(x =0; x < remainder; x++)	{		actualString = actualString + "^";	}	actualString = actualString + getFeed;	cout << actualString << endl;		fd = open(sproutPipe, O_WRONLY);	write(fd, actualString.c_str(), strlen(actualString.c_str()));	close(fd);	return 1;	*/}/*2Sprout API getSproutItem()This function will return a char pointer to the next piece of data*/char * getSproutItem(){		int msqid;    key_t key;    /*     * Get the message queue id for the     * "name" 1234, which was created by     * the server.     */    key = 1234;    if ((msqid = msgget(key, 0666)) < 0) {        perror("msgget");        exit(1);    }        /*     * Receive an answer of message type 1.     */    if (msgrcv(msqid, &rbuf, MSGSZ, 1, 0) < 0) {        perror("msgrcv");        exit(1);    }    /*     * Print the answer.     */    //printf("RECIEVED %s\n", rbuf.mtext);	return rbuf.mtext;	}