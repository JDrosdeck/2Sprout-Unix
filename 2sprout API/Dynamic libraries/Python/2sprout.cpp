/*THIS IS AN UNPUBLISHED WORK CONTAINING 2SPROUT INC CONFIDENTIAL AND PROPRIETARY INFORMATION. DISCLOSURE, USE, OR REPRODUCTION WITHOUT AUTHORIZATION OF 2SPROUT INC IS STRICTLY PROHIBITED.*/#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <errno.h>#include <string.h>#include <iostream>#include <ctype.h>#include <sys/stat.h>#include <fcntl.h>#include <fstream>#include <sys/types.h>#include <unistd.h>#include <queue>#include <cstdlib>#define sproutPipe "/tmp/2sprout"#define feedPipe "/tmp/feedPipe"#define maxFeedPipe		50000using namespace std;queue<string> feedData;string apiPath;string dataPath;string pathToSendClient;bool isFirst = true;int startFeed(){		int fd,n;	char buffer[50];	n = sprintf(buffer, "startFeed");	fd = open(sproutPipe, O_WRONLY);	write(fd, buffer, strlen(buffer));	close(fd);	return 1;}int stopFeed(){	int fd,n;	char buffer[50];	n = sprintf(buffer, "stopFeed");	fd = open(sproutPipe, O_WRONLY);	write(fd, buffer, strlen(buffer));	close(fd);	return 1;}int getFeed(){	int fd,n;	char buffer[50];	n = sprintf(buffer, "getFeed");	fd = open(sproutPipe, O_WRONLY);	write(fd, buffer, strlen(buffer));	printf("getFeed api call complete");	close(fd);		int fd1, numread;	char bufpipe[maxFeedPipe];		printf("Waiting for data on pipe\n");	while(1)	{		fd1 = open(feedPipe, O_RDONLY);		numread = read(fd1,bufpipe, maxFeedPipe);		if(numread > 1)		{		bufpipe[numread] = '\0';		feedData.push(bufpipe);		memset(bufpipe,'\0',maxFeedPipe +1);		printf("PUSHED\n");		close(fd1); //need to recompile with this		}	}	return 1;}char * getNextItem(){	printf("AT Start of getNextItem\n");		while(1)	{		if(usleep(1000) == -1)		{			printf("Sleeping Error");		}				if(!feedData.empty())		{			printf("VALUES\n");			string g = feedData.front();			feedData.pop();			return (char *)g.c_str();		}		if(feedData.empty())		{			printf("huh\n");		}	}				}/*when a developer is using the api they must program using at least two threads, one which calls getFeed()Which will constantly read from the pipe to gather new data, and another which calls getNextItem() whichreturns the next value in the queue.*/